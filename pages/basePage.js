/** * Base Page class for all page objects * Contains common functionality shared across all pages */\nclass BasePage {\n  constructor(page) {\n    this.page = page;\n  }\n\n  async goto(url) {\n    await this.page.goto(url);\n  }\n\n  async goHome() {\n    await this.page.goto('/');\n  }\n\n  async getPageTitle() {\n    return await this.page.title();\n  }\n\n  getCurrentUrl() {\n    return this.page.url();\n  }\n\n  async waitForElement(selector, timeout = 5000) {\n    await this.page.waitForSelector(selector, { timeout });\n  }\n\n  async isElementVisible(selector) {\n    try {\n      await this.page.waitForSelector(selector, { timeout: 3000 });\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  async click(selector) {\n    await this.page.click(selector);\n  }\n\n  async fill(selector, text) {\n    await this.page.fill(selector, text);\n  }\n\n  async getText(selector) {\n    return await this.page.textContent(selector) || '';\n  }\n\n  async getAttribute(selector, attribute) {\n    return await this.page.getAttribute(selector, attribute);\n  }\n\n  async takeScreenshot(fileName) {\n    await this.page.screenshot({ path: `./screenshots/${fileName}.png` });\n  }\n\n  async waitForPageLoad() {\n    await this.page.waitForLoadState('networkidle');\n  }\n\n  async scrollToElement(selector) {\n    await this.page.locator(selector).scrollIntoViewIfNeeded();\n  }\n\n  async elementExists(selector) {\n    try {\n      const count = await this.page.locator(selector).count();\n      return count > 0;\n    } catch {\n      return false;\n    }\n  }\n\n  async clickIfExists(selectors) {\n    if (typeof selectors === 'string') {\n      selectors = [selectors];\n    }\n\n    for (const selector of selectors) {\n      try {\n        const exists = await this.elementExists(selector);\n        if (exists) {\n          await this.page.locator(selector).first().click({ force: true });\n          return true;\n        }\n      } catch {\n        continue;\n      }\n    }\n    return false;\n  }\n\n  async fillIfExists(selectors, text) {\n    if (typeof selectors === 'string') {\n      selectors = [selectors];\n    }\n\n    for (const selector of selectors) {\n      try {\n        const exists = await this.elementExists(selector);\n        if (exists) {\n          await this.page.locator(selector).first().fill(text);\n          return true;\n        }\n      } catch {\n        continue;\n      }\n    }\n    return false;\n  }\n\n  async getTextIfExists(selectors) {\n    if (typeof selectors === 'string') {\n      selectors = [selectors];\n    }\n\n    for (const selector of selectors) {\n      try {\n        const exists = await this.elementExists(selector);\n        if (exists) {\n          return await this.page.locator(selector).first().textContent();\n        }\n      } catch {\n        continue;\n      }\n    }\n    return '';\n  }\n\n  async waitForAny(selectors, timeout = 5000) {\n    if (typeof selectors === 'string') {\n      selectors = [selectors];\n    }\n\n    const startTime = Date.now();\n    while (Date.now() - startTime < timeout) {\n      for (const selector of selectors) {\n        const exists = await this.elementExists(selector);\n        if (exists) {\n          return true;\n        }\n      }\n      await this.page.waitForTimeout(100);\n    }\n    return false;\n  }\n\n  async clickSafe(selector, retries = 3) {\n    for (let i = 0; i < retries; i++) {\n      try {\n        await this.page.locator(selector).first().click({ force: true });\n        return true;\n      } catch {\n        if (i < retries - 1) {\n          await this.page.waitForTimeout(200);\n        }\n      }\n    }\n    return false;\n  }\n\n  async isPageLoaded() {\n    try {\n      await this.page.waitForTimeout(500);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n}\n\nmodule.exports = { BasePage };